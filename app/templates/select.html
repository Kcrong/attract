<!DOCTYPE html>
<html>

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta charset="UTF-8">
  <script src="http://cdn.jsdelivr.net/interact.js/1.2.4/interact.min.js"></script>
  <title>example</title>

  <!-- 보조 함수 -->
  <style>
    #outer-dropzone {
      height: 140px;
      background-color: #ccc;
      border: dashed 4px transparent;
      border-radius: 4px;
      margin: 500px 500px 100px 100px;
      width: 80%;
      transition: background-color 0.3s;
    }
    
    .drop-active {
      border-color: #aaa;
    }
    
    .drop-target {
      background-color: #29e;
      border-color: #fff;
      border-style: solid;
    }
    
    .drag-drop {
      display: inline-block;
      min-width: 40px;
      padding: 2em 0.5em;
      color: #fff;
      background-color: #29e;
      border: solid 2px #fff;
      -webkit-transform: translate(0px, 0px);
      transform: translate(0px, 0px);
      transition: background-color 0.3s;
    }
    
    .drag-drop.can-drop {
      color: #000;
      background-color: #4e4;
    }
  </style>
  <script>
    var movingTexts = {};
    /* The dragging code for '.draggable' from the demo above
     * applies to this demo as well so it doesn't have to be repeated. */
    // enable draggables to be dropped into this
    interact('.draggable')
      .draggable({
        // enable inertial throwing
        inertia: true,
        // keep the element within the area of it's parent
        restrict: {
          restriction: "parent",
          endOnly: true,
          elementRect: {
            top: 0,
            left: 0,
            bottom: 1,
            right: 1
          }
        },

        // call this function on every dragmove event
        onmove: dragMoveListener,
        // call this function on every dragend event

      });

    function dragMoveListener(event) {
      var target = event.target,
        // keep the dragged position in the data-x/data-y attributes
        x = (parseFloat(target.getAttribute('data-x')) || 0) + event.dx,
        y = (parseFloat(target.getAttribute('data-y')) || 0) + event.dy;

      // translate the element
      target.style.webkitTransform =
        target.style.transform =
        'translate(' + x + 'px, ' + y + 'px)';

      // update the posiion attributes
      target.setAttribute('data-x', x);
      target.setAttribute('data-y', y);
    }

    // this is used later in the resizing demo
    window.dragMoveListener = dragMoveListener;

    interact('#outer-dropzone').dropzone({
      // only accept elements matching this CSS selector
      //accept: '#yes-drop',
      // Require a 75% element overlap for a drop to be possible
      overlap: 0.75,

      // listen for drop related events:

      ondropactivate: function(event) {
        // add active dropzone feedback
        event.target.classList.add('drop-active');
      },
      ondragenter: function(event) {

        var draggableElement = event.relatedTarget,
          dropzoneElement = event.target;

        // feedback the possibility of a drop
        dropzoneElement.classList.add('drop-target');
        draggableElement.classList.add('can-drop');
        //draggableElement.textContent = 'Dragged in';
      },
      ondragleave: function(event) {

        // remove the drop feedback style
        var text = event.relatedTarget.textContent
        event.target.classList.remove('drop-target');
        event.relatedTarget.classList.remove('can-drop');
        for (var i in movingTexts) {
          try {
            mText = movingTexts[i].body.innerHTML;
          } catch (ex) {
            mText = "";
            console.log(ex);
          }
          if (mText == text)
            movingTexts[i].dragIn = false;

        }
        //movingTexts.append(event.relatedTarget);
        //event.relatedTarget.textContent = 'Dragged out';
      },
      ondrop: function(event) {
        var text = event.relatedTarget.textContent
        for (var i in movingTexts) {
          console.log(movingTexts[i]);
          try {
            mText = movingTexts[i].body.innerHTML;
          } catch (ex) {
            mText = "";
            console.log(ex);
          }

          if (mText == text) {
            console.log("delete")
            movingTexts[i].dragIn = true;
            break;
          }
        }
      },
      ondropdeactivate: function(event) {

        // remove active dropzone feedback
        event.target.classList.remove('drop-active');
        event.target.classList.remove('drop-target');
      }
    });


    function load_proc() {

      document.oncontextmenu = function() {
        return false
      };
      document.onmousedown = function() {
        return false
      };
    }

    if (window.attachEvent) window.attachEvent("onload", load_proc);
    else window.addEventListener("load", load_proc, false);

    function nextRandomInteger(limit) {
      return Math.round(Math.random() * limit);
    }



    //양음으로 랜덤한 속도를 생성하는 함수
    function randomSpeed(maxSpeed) {
      return Math.random();
    }

    //MovingText의 생성자 함수

    var canvasWidth = window.innerWidth;
    var canvasHeight = window.innerHeight;
    var collect = "";

    function MovingText(text) {
      this.x = nextRandomInteger(canvasWidth);
      this.y = nextRandomInteger(canvasHeight);
      this.vX = randomSpeed(10);
      this.vY = randomSpeed(10);

      this.rate = 10;
      this.elmH = Math.floor(Math.random() * 360) + 1; // Hue
      this.elmS = 128; // Saturation
      this.elmV = 255; // Value 

      this.dragIn = false
        //문서 객체 생성
      this.body = document.createElement('p');

      this.body.style.fontSize = "35px";
      this.body.style.fontWeight = 'bold';
      this.body.style.fontFamily = "Neo";
      this.body.innerHTML = text;
      this.body.style.position = 'absolute';
      this.body.setAttribute("class", "draggable drag-drop");

      //문서 객체를 document.body에 추가
      document.body.appendChild(this.body);
    }

    MovingText.prototype.move = function() {

      //범위 검사
      if (this.x < 0 || this.x > canvasWidth) {
        this.vX *= -1;
      }
      if (this.x > canvasWidth && this.vX > 0) {
        this.vX *= -1;
      }
      if (this.y < 0 || this.y > canvasHeight) {
        this.vY *= -1;
      }
      if (this.y > canvasHeight & this.vY > 0) {
        this.vY *= -1;
      }
      //이동
      this.x += this.vX;
      this.y += this.vY;

      //화면에 이동 표시
      this.body.style.left = this.x + 'px';
      this.body.style.top = this.y + 'px';
    }



    window.onload = function() {
      var texts = ["p1", "p11", "p2", "p3", "p4", "p5"];
      //배열에 MovingText 객체 100개 생성
      for (var i = 0; i < texts.length; i++) 
      {
        movingTexts[i] = new MovingText(texts[i]);
      }
        
      setInterval(function() {

        canvasWidth = window.innerWidth - 45;
        canvasHeight = window.innerHeight - 91;
      }, 500);

      setInterval(function() {
        for (var i in movingTexts) 
        {
          if (movingTexts[i].dragIn == false) 
          {
            movingTexts[i].move();
          }
        }
      }, 20);
    }
  </script>
</head>

<body>
  <div class="draggable drag-drop" id="pp" style="font-size: 35px; font-weight: bold; font-family: Neo;">p121</div>

  <div id="no-drop" class="draggable drag-drop"> #no-drop </div>

  <div id="yes-drop" class="draggable drag-drop">
    <p>#yes-drop</p>
  </div>

  <div id="outer-dropzone" class="dropzone">
    #outer-dropzone
  </div>
</body>

</html>